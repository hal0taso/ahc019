# ahc019
AtCoder Heuristic Contest 019

## Problem
### Input
* D: integer
* $f_1$ : $D \times D$ array representing the silhouette of $G_1$ in the $z$-$x$ plane 
* $r_1$ : $D \times D$ array representing the silhouette of $G_1$ in the  $z$-$y$ plane
* $f_2$ : $D \times D$ array representing the silhouette of $G_2$ in the $z$-$x$ plane
* $r_2$ : $D \times D$ array representing the silhouette of $G_2$ in the $z$-$y$ plane

### Formulation
* Let $G_1$, $G_2$ be two (undirected) graph whose vertex is $v$;
  * I use $G_i$ to represent two assemble pattern whose silhouette matches $f_i$ and $r_i$.

* $G_i$ is defined as 
  * $V(G_i)$;
  * $E(G_i) = \{\{(x, y, z), (x+1, y, z)\}\colon x \in [D-1]\} \cup \{\{(x, y, z), (x, y+1, z)\}\colon y \in [D-1]\} \cup \{\{(x, y, z), (x, y, z+1)\}\colon z \in [D-1]\}$

* I considered that each connected components of $G_1$ and $G_2$ as a piece of puzzle.

* To maintain common components, I considered $G = G_1 \cup G_2$ as a union of two graph.
  * If two connected components $c_1 \subseteq G_1$ and $c_2 \subseteq G_2$ is same piece, then I define $c = c_1 \cup c_2$ as a connected components which represents the common piece.

* Use an union find to maintain the connected components in $G$.

### Basic Idea: a greedy approach
1. Starts from a state with all vertices are isolated.
2. Chose $r \in V(G_1)$ and $p \in V(G_2)$, and axis of rotation (defined as `axis`) and degree (defined as `unit`).
3. From $r$ and $p$, run BFS. In the BFS step, I defined following rules:
  * In $G$, two pair of vertices $(r, p)$ and $(u, q)$ can be united if they hold following all conditions 
    * $\{r, u\} \in E(G_1)$
    * $\{p, q\} \in E(G_2)$
    * $r, p, u, q$ are all isolated
  * $q$ is defined by a given `axis`, `unit` and difference of coordinates of $r$ and $u$.
4. Take the best state as a new state, and go to step 2.

### First Improvement: a beam search
* Choose candidates of $r$ and $p$ randomly
* keep top $k$-th states in each iteration
  * But I didn't notice that I embeded a bug (hold one state every iteration = it's simple greedy!)

### Second Improvement: calculate a hash value of a state
* After bfs step, I noticed that almost states has same scores.
  * I supposed that same states can be generated by different choices of $(r, p, unit, axis)$.
  * I used a Zobrist hash to prevent to keep same states at same level of search.
    * When I compute a Zobrist hash for each states, I assigned a random number for each tuple of $(v, root(v))$, where $v \in G$ and $root(v)$ is a root vertex of the Union-Find tree.
      * to keep reproducibility of the hash value, I modified my Union-Find so that it always stores the smallest value of the set.

## Second Improvement: performance improvement of computing score/hash
* However, it was expensive to compute scores and hash values of all bfs searched states in each iteration.
* Basic idea (of score evaluation): compute for merged components and isolated vertices separatelly.
  1. In my algorithm, for each vertex, merge operation will be done at most one time.
  2. It is sufficient to update scores only when bfs search (and merge operation) has completed for designated $r$ and $p$.
  3. After bfs seach procedure, I updates the score for connected components by adding $10^6 \times \frac{1}{v_i}$ (I used a smaller constant than in official problem website because it can be overflowed in early stage).
   * During merge operation, I also maintained silhouettes made only by merged vertices.
  4. Finaly, I updates the remaining scores for isolated components.
    * In order to remember which is isolated, I prepared a set of vertices named `flagment`.

* Basic idea(of hash calculation): compute only for merged components.
  1. As I mentioned, each vertex will be united at most one time.
  2. Prepare a set of vertex `dirty_vertex` which maintains merged vertices.
  3. When bfs search was stopped (i.e., one search procedure for specific $r \in V(G_1)$ and $p \in V(G_2)$ has completed), I updated the hash value using random numbers assined for $v$ in `dirty_vertex`.


## Other features (but I'm not sure each of them has any effect..)
I changed following parameters depends on an input size $D$.

1. Change the number of samples to be searched by bfs between early stage of search and later stage.
  * The value will be changed linearly from `s_samplesize` to `e_samplesize`.
2. Parameterized width of beam search (defined as `beamwidth`)
3. Restrict the search depth by a `maxdepth` parameter.
4. Switch the search algorithm depends on $D$
  * I tried all possible `axis` and `unit` for small $D$.
  * For large $D$, I choose `axis` and `unit` randomly.


